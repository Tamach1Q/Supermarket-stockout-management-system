<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Area Editor</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #0f1115;
      overflow: hidden;
    }

    #stage {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      box-sizing: border-box;
    }

    canvas {
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.45);
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      outline: none;
    }

    /* 入力モーダル（常時は非表示） */
    #modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    #modal.open {
      display: flex;
    }
    #modalCard {
      width: min(440px, calc(100vw - 48px));
      background: rgba(255,255,255,0.95);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      padding: 18px;
      box-sizing: border-box;
    }
    #areaName {
      width: 100%;
      height: 44px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.12);
      padding: 0 12px;
      font-size: 16px;
      outline: none;
      box-sizing: border-box;
      background: #fff;
    }
    #areaName:focus {
      border-color: rgba(0,0,0,0.25);
    }
    #modalActions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      justify-content: flex-end;
    }
    .btn {
      height: 40px;
      border: 0;
      border-radius: 10px;
      padding: 0 14px;
      font-weight: 700;
      cursor: pointer;
      font-size: 14px;
    }
    .btn.secondary {
      background: rgba(0,0,0,0.08);
      color: #111;
    }
    .btn.primary {
      background: #111827;
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="map" tabindex="0"></canvas>
  </div>

  <div id="modal" aria-hidden="true">
    <div id="modalCard">
      <input id="areaName" type="text" autocomplete="off" placeholder="エリア名" />
      <div id="modalActions">
        <button class="btn secondary" id="cancelBtn" type="button">キャンセル</button>
        <button class="btn primary" id="okBtn" type="button">決定</button>
      </div>
    </div>
  </div>

  <script>
    const LEGACY_CANVAS_W = 600;
    const LEGACY_CANVAS_H = 400;

    const canvas = document.getElementById('map');
    const ctx = canvas.getContext('2d', { alpha: false });
    const stage = document.getElementById('stage');

    const modal = document.getElementById('modal');
    const areaNameInput = document.getElementById('areaName');
    const cancelBtn = document.getElementById('cancelBtn');
    const okBtn = document.getElementById('okBtn');

    const mapImg = new Image();
    let mapLoaded = false;
    let mapW = 900;
    let mapH = 650;

    let areas = [];

    const view = {
      scale: 1,
      offsetX: 0,
      offsetY: 0,
      minScale: 0.2,
      maxScale: 10
    };

    const pointers = new Map(); // pointerId -> {x,y}
    let mode = null; // 'draw' | 'pan' | 'pinch'
    let spaceDown = false;

    let drawStart = null; // {x,y} in map px
    let drawCurrent = null; // {x,y} in map px
    let pendingRect = null; // {x,y,w,h} in map px

    let panLast = null; // {x,y} in canvas CSS px
    let pinchState = null; // {startScale,startOffsetX,startOffsetY,startCenter,startDist}

    function dpr() {
      return window.devicePixelRatio || 1;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function canvasCssSize() {
      const r = canvas.getBoundingClientRect();
      return { w: r.width, h: r.height, left: r.left, top: r.top };
    }

    function setCanvasSize(cssW, cssH) {
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.max(1, Math.round(cssW * dpr()));
      canvas.height = Math.max(1, Math.round(cssH * dpr()));
      ctx.setTransform(dpr(), 0, 0, dpr(), 0, 0);
    }

    function fitToStage() {
      const margin = 24;
      const maxW = Math.max(240, stage.clientWidth - margin * 2);
      const maxH = Math.max(240, stage.clientHeight - margin * 2);
      const aspect = mapW / mapH;

      let cssW = maxW;
      let cssH = cssW / aspect;
      if (cssH > maxH) {
        cssH = maxH;
        cssW = cssH * aspect;
      }

      setCanvasSize(cssW, cssH);

      // 画像全体がぴったり入る初期ビュー
      view.scale = cssW / mapW;
      view.offsetX = (cssW - mapW * view.scale) / 2;
      view.offsetY = (cssH - mapH * view.scale) / 2;
      view.minScale = view.scale * 0.5;
      view.maxScale = view.scale * 12;

      clampView();
      draw();
    }

    function clampView() {
      const { w: cssW, h: cssH } = canvasCssSize();
      const mapScreenW = mapW * view.scale;
      const mapScreenH = mapH * view.scale;

      const minX = Math.min(0, cssW - mapScreenW);
      const minY = Math.min(0, cssH - mapScreenH);
      const maxX = Math.max(0, cssW - mapScreenW);
      const maxY = Math.max(0, cssH - mapScreenH);

      view.offsetX = clamp(view.offsetX, minX, maxX);
      view.offsetY = clamp(view.offsetY, minY, maxY);
    }

    function canvasPointFromEvent(e) {
      const r = canvas.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    function mapPointFromCanvasPoint(p) {
      const x = (p.x - view.offsetX) / view.scale;
      const y = (p.y - view.offsetY) / view.scale;
      return {
        x: clamp(x, 0, mapW),
        y: clamp(y, 0, mapH),
      };
    }

    function rectNormalize(a, b) {
      const x1 = Math.min(a.x, b.x);
      const y1 = Math.min(a.y, b.y);
      const x2 = Math.max(a.x, b.x);
      const y2 = Math.max(a.y, b.y);
      return { x: x1, y: y1, w: x2 - x1, h: y2 - y1 };
    }

    function drawFallbackMap() {
      // generate_dummy.py の配置をざっくり再現（文字なし）
      ctx.save();
      ctx.translate(view.offsetX, view.offsetY);
      ctx.scale(view.scale, view.scale);

      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, mapW, mapH);

      ctx.lineJoin = 'miter';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      const m = 20;
      ctx.strokeRect(m, m, mapW - m * 2, mapH - m * 2);

      function shelf(x, y, w, h, lineW = 2) {
        ctx.lineWidth = lineW;
        ctx.strokeRect(x, y, w, h);
      }

      shelf(150, m + 20, 600, 50);
      shelf(m + 20, 150, 50, 350);

      const shelfW = 40;
      const shelfH = 350;
      const startX = 150;
      const gapX = 30;
      for (let i = 0; i < 7; i++) {
        shelf(startX + i * (shelfW + gapX), 150, shelfW, shelfH);
      }

      const produceX = startX + 7 * (shelfW + gapX) + 20;
      shelf(produceX, 150, 120, 350);

      const checkoutY = 550;
      for (let i = 0; i < 4; i++) {
        shelf(300 + i * 80, checkoutY, 30, 60);
      }

      // 入口の開口＆ドア（右下）
      ctx.lineWidth = 3;
      const doorY = mapH - m - 80;
      const doorSize = 60;
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(mapW - m, doorY);
      ctx.lineTo(mapW - m, doorY + doorSize);
      ctx.stroke();

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      // arc: center (mapW-m, doorY+doorSize) radius doorSize
      ctx.arc(mapW - m, doorY + doorSize, doorSize, Math.PI, Math.PI * 1.5);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(mapW - m, doorY + doorSize);
      ctx.lineTo(mapW - m - doorSize, doorY + doorSize);
      ctx.stroke();

      ctx.restore();
    }

    function draw() {
      const { w: cssW, h: cssH } = canvasCssSize();
      ctx.clearRect(0, 0, cssW, cssH);

      if (mapLoaded && mapImg.complete && mapImg.naturalWidth > 0) {
        ctx.save();
        ctx.translate(view.offsetX, view.offsetY);
        ctx.scale(view.scale, view.scale);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(mapImg, 0, 0, mapW, mapH);
        ctx.restore();
      } else {
        drawFallbackMap();
      }

      // 保存済みエリア（ラベルは描かない）
      for (const a of areas) {
        const sx = a.x * view.scale + view.offsetX;
        const sy = a.y * view.scale + view.offsetY;
        const sw = a.w * view.scale;
        const sh = a.h * view.scale;

        ctx.fillStyle = 'rgba(59, 130, 246, 0.14)';
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.95)';
        ctx.lineWidth = 2;
        ctx.fillRect(sx, sy, sw, sh);
        ctx.strokeRect(sx, sy, sw, sh);
      }

      // ドラッグ中の矩形
      if (mode === 'draw' && drawStart && drawCurrent) {
        const r = rectNormalize(drawStart, drawCurrent);
        const sx = r.x * view.scale + view.offsetX;
        const sy = r.y * view.scale + view.offsetY;
        const sw = r.w * view.scale;
        const sh = r.h * view.scale;

        ctx.strokeStyle = 'rgba(16, 185, 129, 0.95)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(sx, sy, sw, sh);
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(16, 185, 129, 0.10)';
        ctx.fillRect(sx, sy, sw, sh);
      }
    }

    function openModal() {
      modal.classList.add('open');
      modal.setAttribute('aria-hidden', 'false');
      areaNameInput.value = '';
      setTimeout(() => areaNameInput.focus(), 0);
    }

    function closeModal() {
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden', 'true');
      pendingRect = null;
      draw();
      canvas.focus();
    }

    async function saveAreas() {
      try {
        await fetch('/api/save_areas', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(areas),
        });
      } catch (_) {}
    }

    function migrateAreasIfLegacy(data) {
      if (!Array.isArray(data) || data.length === 0) return data;

      let maxX = 0;
      let maxY = 0;
      for (const a of data) {
        if (!a) continue;
        const x = Number(a.x) || 0;
        const y = Number(a.y) || 0;
        const w = Number(a.w) || 0;
        const h = Number(a.h) || 0;
        maxX = Math.max(maxX, x + w);
        maxY = Math.max(maxY, y + h);
      }

      const looksLegacy = maxX <= LEGACY_CANVAS_W * 1.05 && maxY <= LEGACY_CANVAS_H * 1.05 && (mapW > LEGACY_CANVAS_W + 10 || mapH > LEGACY_CANVAS_H + 10);
      if (!looksLegacy) return data;

      const sx = mapW / LEGACY_CANVAS_W;
      const sy = mapH / LEGACY_CANVAS_H;
      return data.map(a => ({
        name: (a && typeof a.name === 'string') ? a.name : '',
        x: (Number(a.x) || 0) * sx,
        y: (Number(a.y) || 0) * sy,
        w: (Number(a.w) || 0) * sx,
        h: (Number(a.h) || 0) * sy,
      }));
    }

    async function loadAreas() {
      try {
        const res = await fetch('/api/load_areas', { cache: 'no-store' });
        const data = await res.json();
        areas = migrateAreasIfLegacy(Array.isArray(data) ? data : []);
        draw();
      } catch (_) {}
    }

    function shouldStartPan(e) {
      if (spaceDown) return true;
      if (e.pointerType === 'mouse') {
        // 右クリック/中クリックはパン扱い
        return e.button === 1 || e.button === 2;
      }
      return false;
    }

    function beginDraw(mapPoint) {
      mode = 'draw';
      drawStart = mapPoint;
      drawCurrent = mapPoint;
    }

    function beginPan(canvasPoint) {
      mode = 'pan';
      panLast = canvasPoint;
    }

    function beginPinch() {
      mode = 'pinch';
      const pts = [...pointers.values()];
      const p1 = pts[0];
      const p2 = pts[1];
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const dist = Math.hypot(dx, dy) || 1;
      const center = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      pinchState = {
        startScale: view.scale,
        startOffsetX: view.offsetX,
        startOffsetY: view.offsetY,
        startCenter: center,
        startDist: dist
      };
    }

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    canvas.addEventListener('pointerdown', (e) => {
      canvas.focus();
      canvas.setPointerCapture(e.pointerId);
      const cp = canvasPointFromEvent(e);
      pointers.set(e.pointerId, cp);

      if (pointers.size === 2) {
        beginPinch();
        draw();
        return;
      }

      if (modal.classList.contains('open')) return;

      if (shouldStartPan(e)) {
        beginPan(cp);
        return;
      }

      const mp = mapPointFromCanvasPoint(cp);
      beginDraw(mp);
      draw();
    });

    canvas.addEventListener('pointermove', (e) => {
      const cp = canvasPointFromEvent(e);
      if (pointers.has(e.pointerId)) {
        pointers.set(e.pointerId, cp);
      }

      if (mode === 'pinch' && pointers.size >= 2 && pinchState) {
        const pts = [...pointers.values()].slice(0, 2);
        const p1 = pts[0];
        const p2 = pts[1];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const dist = Math.hypot(dx, dy) || 1;
        const center = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

        const factor = dist / pinchState.startDist;
        const newScale = clamp(pinchState.startScale * factor, view.minScale, view.maxScale);

        const centerMapX = (pinchState.startCenter.x - pinchState.startOffsetX) / pinchState.startScale;
        const centerMapY = (pinchState.startCenter.y - pinchState.startOffsetY) / pinchState.startScale;

        view.scale = newScale;
        view.offsetX = center.x - centerMapX * newScale;
        view.offsetY = center.y - centerMapY * newScale;
        clampView();
        draw();
        return;
      }

      if (mode === 'pan' && panLast) {
        const dx = cp.x - panLast.x;
        const dy = cp.y - panLast.y;
        view.offsetX += dx;
        view.offsetY += dy;
        panLast = cp;
        clampView();
        draw();
        return;
      }

      if (mode === 'draw' && drawStart) {
        drawCurrent = mapPointFromCanvasPoint(cp);
        draw();
      }
    });

    function finishDraw() {
      if (!drawStart || !drawCurrent) return;
      const r = rectNormalize(drawStart, drawCurrent);
      drawStart = null;
      drawCurrent = null;

      // 小さすぎる矩形は無視
      if (r.w < 8 || r.h < 8) {
        mode = null;
        draw();
        return;
      }

      pendingRect = r;
      mode = null;
      openModal();
    }

    canvas.addEventListener('pointerup', (e) => {
      pointers.delete(e.pointerId);

      if (mode === 'pinch') {
        if (pointers.size < 2) {
          pinchState = null;
          mode = null;
        }
        return;
      }

      if (mode === 'pan') {
        mode = null;
        panLast = null;
        return;
      }

      if (mode === 'draw') {
        finishDraw();
      }
    });

    canvas.addEventListener('pointercancel', (e) => {
      pointers.delete(e.pointerId);
      mode = null;
      panLast = null;
      pinchState = null;
      drawStart = null;
      drawCurrent = null;
      draw();
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      if (modal.classList.contains('open')) return;

      const cp = canvasPointFromEvent(e);
      const before = mapPointFromCanvasPoint(cp);
      const zoom = Math.exp(-e.deltaY * 0.0012);
      const newScale = clamp(view.scale * zoom, view.minScale, view.maxScale);

      view.scale = newScale;
      view.offsetX = cp.x - before.x * newScale;
      view.offsetY = cp.y - before.y * newScale;
      clampView();
      draw();
    }, { passive: false });

    function confirmAreaName() {
      const name = areaNameInput.value.trim();
      if (!pendingRect || !name) {
        closeModal();
        return;
      }
      areas.push({ ...pendingRect, name });
      pendingRect = null;
      closeModal();
      saveAreas();
      draw();
    }

    cancelBtn.addEventListener('click', closeModal);
    okBtn.addEventListener('click', confirmAreaName);
    areaNameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') confirmAreaName();
      if (e.key === 'Escape') closeModal();
    });
    modal.addEventListener('pointerdown', (e) => {
      if (e.target === modal) closeModal();
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === ' ') spaceDown = true;

      // 入力中はショートカット無効
      if (modal.classList.contains('open')) return;

      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
        e.preventDefault();
        saveAreas();
      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        areas.pop();
        saveAreas();
        draw();
      } else if (e.key === 'Escape') {
        mode = null;
        panLast = null;
        pinchState = null;
        drawStart = null;
        drawCurrent = null;
        draw();
      } else if (e.key.toLowerCase() === 'r') {
        if (confirm('エリア設定をすべて消しますか？')) {
          areas = [];
          saveAreas();
          draw();
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === ' ') spaceDown = false;
    });

    function loadMap() {
      const src = (location.protocol === 'file:')
        ? '../static/map.png'
        : '/static/map.png?t=' + Date.now();

      mapLoaded = false;
      mapImg.onload = () => {
        mapLoaded = true;
        mapW = mapImg.naturalWidth || mapW;
        mapH = mapImg.naturalHeight || mapH;
        fitToStage();
        loadAreas();
      };
      mapImg.onerror = () => {
        mapLoaded = false;
        mapW = 900;
        mapH = 650;
        fitToStage();
        loadAreas();
      };
      mapImg.src = src;
    }

    // 地図更新（SLAM等）に追従
    setInterval(() => {
      if (location.protocol === 'file:') return;
      const probe = new Image();
      probe.onload = () => {
        if (!mapLoaded || probe.src !== mapImg.src) {
          mapImg.src = probe.src;
        }
      };
      probe.src = '/static/map.png?t=' + Date.now();
    }, 15000);

    window.addEventListener('resize', () => fitToStage());
    loadMap();
    canvas.focus();
  </script>
</body>
</html>

